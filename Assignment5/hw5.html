<!DOCTYPE html>
<html>
<head>
<meta charset="UTF-8">
<title>Assignment 5</title>
<link rel="stylesheet" href="demo.css">
 
<script type="x-shader/x-vertex" id="vshader-source">
    attribute vec3 a_coords;
    attribute vec3 a_normal;
    attribute vec2 a_texCoords;
    uniform mat4 modelview;
    uniform mat4 projection;
    varying vec3 v_normal;
    varying vec3 v_objCoords;
    varying vec3 v_eyeCoords;
    varying vec2 v_texCoords;
    void main() {
        vec4 objectCoords = vec4(a_coords,1.0);
        vec4 eyeCoords = modelview * objectCoords;
        gl_Position = projection * eyeCoords;
        v_normal = normalize(a_normal);
        v_objCoords = a_coords;
        v_eyeCoords = eyeCoords.xyz/eyeCoords.w;
        v_texCoords = a_texCoords;
    }
</script>

<script type="x-shader/x-fragment" id="fshader-source">
    #ifdef GL_FRAGMENT_PRECISION_HIGH
       precision highp float;
    #else
       precision mediump float;
    #endif
    uniform mat3 normalMatrix;
    uniform int textureNum;
    uniform int flag; // whether procedureal or image picture 
    uniform float scale;  // scaling factor for texture coordinates, to shrink the texture on objects.
    uniform sampler2D picture;
    varying vec3 v_normal;
    varying vec3 v_eyeCoords;
    varying vec3 v_objCoords;
    varying vec2 v_texCoords;
 
    void main() {
        vec3 N = normalize( normalMatrix*v_normal );
        vec3 L = normalize( -v_eyeCoords);  // (Assumes a perspective projection.)
        float diffuseFactor = dot(N,L);
        vec3 color;
        if  ( flag == 1 )  {
           vec4 color4 = texture2D(picture, vec2(v_texCoords.s, v_texCoords.t));  
           gl_FragColor = vec4( diffuseFactor*color4.xyz, 1.0);
        }
        else {
        
            if (textureNum == 0)  {  // checkerboard texture 2D
                float a = floor(v_texCoords.x * scale);
                float b = floor(v_texCoords.y * scale);
                if (mod(a+b, 2.0) > 0.5) {  // a+b is odd
                    //color = vec3(1.0, 0.5, 0.5);
                    color = vec3(1.0, 1.0, 1.0);
                }
                else {  // a+b is even
                    color = vec3(0, 0, 0.8);
                }
            }
            else if  (textureNum <= 1) {  // checkerboard texture 3D, based on object coords
                float a = floor(v_objCoords.x * scale);
                float b = floor(v_objCoords.y * scale);
                float c = floor(v_objCoords.z * scale);
                if (mod(a+b+c, 2.0) > 0.5) {  // a+b+c is odd
                    //color = vec3(0.5, 1.0, 0.5);
                    color = vec3(0.0, 0.0, 0.8);
                }
                
                else {  // a+b+c is even
                    color = vec3(1.0, 1.0, 1.0);
                }
            }
            else  {  // #3 (Triangle Function) 
                vec3 v = v_objCoords*scale;
                float t = (v.x + 2.0*v.y + v.z)*0.25;
                float value = t - floor(t);
                //value = value*(1.0 - smoothstep(0.95,1.0,value));  // smooth out the discontinuity
                value = 0.333 + value*0.667;
                color = vec3(value, value, 1);
            }
            
            gl_FragColor = vec4( diffuseFactor*color, 1.0);
       }
      
    }
</script>

<!-- Skybox shader -->
<script type="x-shader/x-vertex" id="vshaderSB">
     uniform mat4 projection;
     uniform mat4 modelview;
     attribute vec3 coords;
     varying vec3 v_objCoords;
     void main() {
        vec4 eyeCoords = modelview * vec4(coords,1.0);
        gl_Position = projection * eyeCoords;
        v_objCoords = coords;
     }
</script>
<script type="x-shader/x-fragment" id="fshaderSB">
     precision mediump float;
     varying vec3 v_objCoords;
     uniform samplerCube skybox;
     void main() {
          gl_FragColor = textureCube(skybox, v_objCoords);
     }
</script>

<!-- reflecting model shader -->
<script type="x-shader/x-vertex" id="vshaderRM">
     uniform mat4 projection;
     uniform mat4 modelview;
     attribute vec3 coords;
     attribute vec3 normal;
     varying vec3 v_eyeCoords;
     varying vec3 v_normal;
     void main() {
        vec4 eyeCoords = modelview * vec4(coords,1.0);
        gl_Position = projection * eyeCoords;
        v_eyeCoords = eyeCoords.xyz;
        v_normal = normalize(normal);
     }
</script>

<script type="x-shader/x-fragment" id="fshaderRM">
     precision mediump float;
     varying vec3 vCoords;
     varying vec3 v_normal;
     varying vec3 v_eyeCoords;
     uniform samplerCube skybox;
     uniform mat3 normalMatrix;
     uniform mat3 inverseViewTransform;
     void main() {
          vec3 N = normalize(normalMatrix * v_normal);
          vec3 V = -v_eyeCoords;
          vec3 R = -reflect(V,N);
//          vec3 R = 2.0 * dot(V,N) * N - V; // This is how to compute R without the reflect() function.
          vec3 T = inverseViewTransform * R; // Transform by inverse of the view transform that was applied to the skybox
          gl_FragColor = textureCube(skybox, T);
     }
</script>

<script src="script/gl-matrix-min.js"></script>
<script src="script/simple-rotator.js"></script>
<script src="script/trackball-rotator.js"></script>
<script src="script/models.js"></script>
<script src="script/demo-core.js"></script>
<script src="script/jquery-min.js"></script>

<script>
var canvas;
var gl;

//skybox uniforms
var prog_SB, a_coords_loc_SB,  u_modelview_SB , u_projection_SB;
    
//uniform for models in the  skybox
var prog_RM, a_coords_loc_RM, a_normal_loc_RM;
var  u_modelview_RM, u_projection_RM, u_normalMatrix_RM, u_inverseViewTransform_RM ;
    
//Locations of attrbute variables of the models
var a_coords_loc;         
var a_normal_loc;
var a_texCoords_loc;

// Locations for uniform matrices
var u_modelview;       
var u_projection;
var u_normalMatrix;
var u_textureNum;
var u_scale;

var projection = mat4.create();    // projection matrix
var modelview;                     // modelview matrix; value comes from rotator
var normalMatrix = mat3.create();  // matrix, derived from modelview matrix, for transforming normal vectors

//mapping
var projection_SB = mat4.create();    // projection matrix
var modelview_SB;                     // modelview matrix; value comes from rotator
var normalMatrix_RM = mat3.create();  // matrix, derived from modelview matrix, for transforming normal vectors
var inverseViewTransform_RM = mat3.create();  // The inverse of the view transform rotation matrix.
var projection_RM = mat4.create();    // projection matrix

var texID;   // The cubemap texture.

var skyboxCube;

var rotX = 0, rotY = 0;  // Additional rotations applied as modelling transform

var tballRotator;  // A TrackballRotator to implement rotation by mouse.
var rotator;
//////////////////////////////////////////////////////////////////////
// draw  image texture
/////////////////////////////////////////////////////////////////////
 var pictureLoaded;
function draw_image() {
    gl.clearColor(0.3,0.3,0.3,1);
    gl.clear(gl.COLOR_BUFFER_BIT | gl.DEPTH_BUFFER_BIT);
    gl.useProgram(prog);
     gl.enableVertexAttribArray(a_coords_loc);
     gl.enableVertexAttribArray(a_normal_loc);
     
    gl.uniform1i(u_flag, 1);
    if (!pictureLoaded) {
        return;
    }
    modelview = tballRotator.getViewMatrix();
    var objectNum = Number(document.getElementById("object").value);
    objects[objectNum].render();
   
}

/////////////////////////////////////////////////////////////////////
// Draw Computed/Procedural Texture, texture computed on the fly
//////////////////////////////////////////////////////////////////////
function draw_proc() {
    gl.clearColor(0.3,0.3,0.3,1);
    gl.clear(gl.COLOR_BUFFER_BIT | gl.DEPTH_BUFFER_BIT);
        gl.useProgram(prog);
        gl.enableVertexAttribArray(a_coords_loc);
        gl.enableVertexAttribArray(a_normal_loc);
     
    if ( flag == 0 ) {
        var textureNum = Number(document.getElementById("texture").value); 
        var scale = Number(document.getElementById("scale").value); 
        gl.uniform1i(u_flag,0);    
        gl.uniform1i(u_textureNum, textureNum);
        gl.uniform1f(u_scale, scale);
        modelview = tballRotator.getViewMatrix();
        var objectNum = Number(document.getElementById("object").value);
        objects[objectNum].render();
    }  else {
    draw_image();
    }
        
}
///////////////////////////////////////////////////////////////////////////////////
// Draw environmental map
///////////////////////////////////////////////////////////////////////////////////
 function draw_envmap() {
    gl.clearColor(0.3,0.3,0.3,1);
    gl.clear(gl.COLOR_BUFFER_BIT | gl.DEPTH_BUFFER_BIT);
     gl.useProgram(prog_RM);
        gl.enableVertexAttribArray(a_coords_loc_RM);
        gl.enableVertexAttribArray(a_normal_loc_RM);
    
    modelview_RM = rotator.getViewMatrix(); 
    mat3.normalFromMat4(normalMatrix_RM, modelview_RM);
    
    // Draw the skybox, with the viewing transform from the rotator.
    
    gl.useProgram(prog_SB); // Select the shader program that is used for the skybox.
    gl.depthMask(false);
    if (texID) {
        gl.enableVertexAttribArray(a_coords_loc_SB);
        skyboxCube.render();  
        gl.disableVertexAttribArray(a_coords_loc_SB);
    }
    
    // Get the inverse of the rotation that was applied to the skybox.
    // This is needed in the teapot shader to account for the rotation
    // of the skybox.  (Note that it is passed to the shader in the
    // teapot's render function.)
    
    mat3.fromMat4(inverseViewTransform_RM, modelview_RM);
    mat3.invert(inverseViewTransform_RM,inverseViewTransform_RM);

    // Add modeling rotations to the view transform.

    mat4.rotateX(modelview_RM,modelview_RM,rotX);
    mat4.rotateY(modelview_RM,modelview_RM,rotY);
    
    mat3.normalFromMat4(normalMatrix_RM, modelview_RM);
    
    // Draw the object.
    
    var objectNum = Number(document.getElementById("object").value);
    
    gl.useProgram(prog_RM); // Select the shader program that is used for the reflective object.
    gl.depthMask(true);
    if (texID) {
        gl.enableVertexAttribArray(a_coords_loc_RM);
        gl.enableVertexAttribArray(a_normal_loc_RM);
        objects_RM[objectNum].render();  
        gl.disableVertexAttribArray(a_coords_loc_RM);
        gl.disableVertexAttribArray(a_normal_loc_RM);
    }
}

// loads the images for the texture cube, and calls draw_env() when finished 
function loadTextureCube() {
    gl.pixelStorei(gl.UNPACK_FLIP_Y_WEBGL, false);
    document.getElementById("headline").innerHTML = "WebGL Reflection Map With Skybox -- LOADING CUBEMAP TEXTURE";
    var ct = 0;
    var img = new Array(6);
    
    var urls = [
       "cubemap-textures/Yokohama3/posx.jpg", "cubemap-textures/Yokohama3/negx.jpg", 
       "cubemap-textures/Yokohama3/posy.jpg", "cubemap-textures/Yokohama3/negy.jpg", 
       "cubemap-textures/Yokohama3/posz.jpg", "cubemap-textures/Yokohama3/negz.jpg"
    ];
    
    for (var i = 0; i < 6; i++) {
        img[i] = new Image();
        img[i].onload = function() {
            ct++;
            if (ct == 6) {
                document.getElementById("headline").innerHTML = "WebGL Reflection Map With Skybox";
                texID = gl.createTexture();
                //console.log("cube ");
                gl.bindTexture(gl.TEXTURE_CUBE_MAP, texID);
                var targets = [
                   gl.TEXTURE_CUBE_MAP_POSITIVE_X, gl.TEXTURE_CUBE_MAP_NEGATIVE_X, 
                   gl.TEXTURE_CUBE_MAP_POSITIVE_Y, gl.TEXTURE_CUBE_MAP_NEGATIVE_Y, 
                   gl.TEXTURE_CUBE_MAP_POSITIVE_Z, gl.TEXTURE_CUBE_MAP_NEGATIVE_Z 
                ];
                try {
                    for (var j = 0; j < 6; j++) {
                        gl.texImage2D(targets[j], 0, gl.RGBA, gl.RGBA, gl.UNSIGNED_BYTE, img[j]);
                        gl.texParameteri(gl.TEXTURE_CUBE_MAP, gl.TEXTURE_WRAP_S, gl.CLAMP_TO_EDGE);
                        gl.texParameteri(gl.TEXTURE_CUBE_MAP, gl.TEXTURE_WRAP_T, gl.CLAMP_TO_EDGE);
                    }
                } catch(e) {
                    document.getElementById("canvas-holder").innerHTML = "ERROR: CANNOT ACCESS CUBEMAP TEXTURE IMAGES";
                }
                gl.generateMipmap(gl.TEXTURE_CUBE_MAP);
                draw_envmap();
            }
        }
        img[i].onerror = function() {
             document.getElementById("canvas-holder").innerHTML = "ERROR WHILE TRYING TO LOAD CUBEMAP TEXTURE";
        }
        img[i].src = urls[i];
    }
}


//////////////////////////////////////////////////////////////////////////////////
//Creates a shader programs
//////////////////////////////////////////////////////////////////////////////////
function createProgram(gl, vertexShaderID, fragmentShaderID) {
    function getTextContent( elementID ) {
            // This nested function retrieves the text content of an
            // element on the web page.  It is used here to get the shader
            // source code from the script elements that contain it.
        var element = document.getElementById(elementID);
        var node = element.firstChild;
        var str = "";
        while (node) {
            if (node.nodeType == 3) // this is a text node
                str += node.textContent;
            node = node.nextSibling;
        }
        return str;
    }
    try {
        var vertexShaderSource = getTextContent( vertexShaderID );
        var fragmentShaderSource = getTextContent( fragmentShaderID );
    }
    catch (e) {
        throw "Error: Could not get shader source code from script elements.";
    }
    var vsh = gl.createShader( gl.VERTEX_SHADER );
    gl.shaderSource(vsh,vertexShaderSource);
    gl.compileShader(vsh);
    if ( ! gl.getShaderParameter(vsh, gl.COMPILE_STATUS) ) {
        throw "Error in vertex shader:  " + gl.getShaderInfoLog(vsh);
     }
    var fsh = gl.createShader( gl.FRAGMENT_SHADER );
    gl.shaderSource(fsh, fragmentShaderSource);
    gl.compileShader(fsh);
    if ( ! gl.getShaderParameter(fsh, gl.COMPILE_STATUS) ) {
       throw "Error in fragment shader:  " + gl.getShaderInfoLog(fsh);
    }
    var prog = gl.createProgram();
    gl.attachShader(prog,vsh);
    gl.attachShader(prog, fsh);
    gl.linkProgram(prog);
    if ( ! gl.getProgramParameter( prog, gl.LINK_STATUS) ) {
       throw "Link error in program:  " + gl.getProgramInfoLog(prog);
    }
    return prog;
}


///////////////////////////////////////////////////////////////////////////////////////
// hold models data
///////////////////////////////////////////////////////////////////////////////////////
function createModel(modelData) {
    var model = {};
    model.coordsBuffer = gl.createBuffer();
    model.normalBuffer = gl.createBuffer();
    model.texCoordsBuffer = gl.createBuffer();
    model.indexBuffer = gl.createBuffer();
    model.count = modelData.indices.length;
    gl.bindBuffer(gl.ARRAY_BUFFER, model.coordsBuffer);
    gl.bufferData(gl.ARRAY_BUFFER, modelData.vertexPositions, gl.STATIC_DRAW);
    gl.bindBuffer(gl.ARRAY_BUFFER, model.normalBuffer);
    gl.bufferData(gl.ARRAY_BUFFER, modelData.vertexNormals, gl.STATIC_DRAW);
    gl.bindBuffer(gl.ARRAY_BUFFER, model.texCoordsBuffer);
    gl.bufferData(gl.ARRAY_BUFFER, modelData.vertexTextureCoords, gl.STATIC_DRAW);
    gl.bindBuffer(gl.ELEMENT_ARRAY_BUFFER, model.indexBuffer);
    gl.bufferData(gl.ELEMENT_ARRAY_BUFFER, modelData.indices, gl.STATIC_DRAW);
    model.render = function() {  // This function will render the object.
           // Since the buffer from which we are taking the coordinates and normals
           // change each time an object is drawn, we have to use gl.vertexAttribPointer
           // to specify the location of the data. And to do that, we must first
           // bind the buffer that contains the data.  Similarly, we have to
           // bind this object's index buffer before calling gl.drawElements.
        gl.bindBuffer(gl.ARRAY_BUFFER, this.coordsBuffer); 
        gl.vertexAttribPointer(a_coords_loc, 3, gl.FLOAT, false, 0, 0);
        gl.bindBuffer(gl.ARRAY_BUFFER, this.normalBuffer);
        gl.vertexAttribPointer(a_normal_loc, 3, gl.FLOAT, false, 0, 0);
        gl.bindBuffer(gl.ARRAY_BUFFER, this.texCoordsBuffer);
        gl.vertexAttribPointer(a_texCoords_loc, 2, gl.FLOAT, false, 0, 0);
        gl.uniformMatrix4fv(u_modelview, false, modelview );
        mat3.normalFromMat4(normalMatrix, modelview);
        gl.uniformMatrix3fv(u_normalMatrix, false, normalMatrix);
        gl.bindBuffer(gl.ELEMENT_ARRAY_BUFFER, this.indexBuffer);  
        gl.drawElements(gl.TRIANGLES, this.count, gl.UNSIGNED_SHORT, 0);
    }
    return model;
}
function createModelRM(modelData) {  // For creating the reflecting object models.
    var model = {};
    model.coordsBuffer = gl.createBuffer();
    model.normalBuffer = gl.createBuffer();
    model.indexBuffer = gl.createBuffer();
    model.count = modelData.indices.length;
    gl.bindBuffer(gl.ARRAY_BUFFER, model.coordsBuffer);
    gl.bufferData(gl.ARRAY_BUFFER, modelData.vertexPositions, gl.STATIC_DRAW);
    gl.bindBuffer(gl.ARRAY_BUFFER, model.normalBuffer);
    gl.bufferData(gl.ARRAY_BUFFER, modelData.vertexNormals, gl.STATIC_DRAW);
    gl.bindBuffer(gl.ELEMENT_ARRAY_BUFFER, model.indexBuffer);
    gl.bufferData(gl.ELEMENT_ARRAY_BUFFER, modelData.indices, gl.STATIC_DRAW);
    model.render = function() {
        gl.bindBuffer(gl.ARRAY_BUFFER, this.coordsBuffer);
        gl.vertexAttribPointer(a_coords_loc_RM, 3, gl.FLOAT, false, 0, 0);
        gl.bindBuffer(gl.ARRAY_BUFFER, this.normalBuffer);
        gl.vertexAttribPointer(a_normal_loc_RM, 3, gl.FLOAT, false, 0, 0);
        gl.uniformMatrix4fv(u_modelview_RM, false, modelview_RM );
        gl.uniformMatrix3fv(u_normalMatrix_RM, false, normalMatrix_RM);
        gl.uniformMatrix3fv(u_inverseViewTransform_RM, false, inverseViewTransform_RM);
        gl.bindBuffer(gl.ELEMENT_ARRAY_BUFFER, this.indexBuffer);
        gl.drawElements(gl.TRIANGLES, this.count, gl.UNSIGNED_SHORT, 0);
    };
    return model;
}
////////////////////////////////////////////////////////////////////////
// create skybox model
///////////////////////////////////////////////////////////////////////

function createModelSB(modelData) {  // For creating the cube for the skybox.
    var model = {};
    model.coordsBuffer = gl.createBuffer();
    model.indexBuffer = gl.createBuffer();
    model.count = modelData.indices.length;
    gl.bindBuffer(gl.ARRAY_BUFFER, model.coordsBuffer);
    gl.bufferData(gl.ARRAY_BUFFER, modelData.vertexPositions, gl.STATIC_DRAW);
    gl.bindBuffer(gl.ELEMENT_ARRAY_BUFFER, model.indexBuffer);
    gl.bufferData(gl.ELEMENT_ARRAY_BUFFER, modelData.indices, gl.STATIC_DRAW);
    model.render = function() { 
        gl.bindBuffer(gl.ARRAY_BUFFER, this.coordsBuffer);
        gl.vertexAttribPointer(a_coords_loc_SB, 3, gl.FLOAT, false, 0, 0);
        gl.uniformMatrix4fv(u_modelview_SB, false, modelview_RM );
        gl.bindBuffer(gl.ELEMENT_ARRAY_BUFFER, this.indexBuffer);
        gl.drawElements(gl.TRIANGLES, this.count, gl.UNSIGNED_SHORT, 0);
    };
    return model;
}
////////////////////////////////////////////////////////////////////////////////
// Load Texture Image
////////////////////////////////////////////////////////////////////////////////
function loadPicture() {
    pictureLoaded = false;
    gl.pixelStorei( gl.UNPACK_FLIP_Y_WEBGL, 1 );  
    draw_image();
    var pictureNum = Number(document.getElementById("pics").value);
    document.getElementById("headline").innerHTML = "Generated Texture Coordinates -- LOADING TEXTURE";
    var img = new Image();
    img.onload = function() {
        try {
           gl.texImage2D(gl.TEXTURE_2D, 0, gl.RGBA, gl.RGBA, gl.UNSIGNED_BYTE, img);
        }
        catch (e) {
           document.getElementById("headline").innerHTML =
              "SORRY, can't access texture. Note that some<br>browsers can't use a texture from a local disk.";
           return;
        }
        gl.generateMipmap(gl.TEXTURE_2D);
        pictureLoaded = true;
        document.getElementById("headline").innerHTML = "Generated Texture Coordinates";
        draw_image();
    };
    img.onerror = function() {
        document.getElementById("headline").innerHTML = "SORRY, COULDN'T LOAD TEXTURE IMAGE";
    };
    img.src = pictureURLs[pictureNum];
}

var pictureURLs = [
 "pics/petrified-wood.jpg",
 "pics/Earth-1024x512.jpg",
 "pics/earth_lights.jpg",
 "pics/moon.jpg"
];


/////////////////////////////////////////////////////////////////////////////
// Initialize the WebGL graphics context, and clear the canvas
/////////////////////////////////////////////////////////////////////////////
var u_picture;
var flag = 0;
var prog;
function initGL() {
    prog = createProgram( gl, "vshader-source", "fshader-source" );
    prog_SB = createProgram(gl, "vshaderSB", "fshaderSB");
    prog_RM = createProgram(gl, "vshaderRM", "fshaderRM");
    
    a_coords_loc_SB =  gl.getAttribLocation(prog_SB, "coords");
    u_modelview_SB = gl.getUniformLocation(prog_SB, "modelview");
    u_projection_SB = gl.getUniformLocation(prog_SB, "projection");
    prog_RM = createProgram(gl, "vshaderRM", "fshaderRM");
    a_coords_loc_RM =  gl.getAttribLocation(prog_RM, "coords");
    a_normal_loc_RM =  gl.getAttribLocation(prog_RM, "normal");
    u_modelview_RM = gl.getUniformLocation(prog_RM, "modelview");
    u_projection_RM = gl.getUniformLocation(prog_RM, "projection");
    u_normalMatrix_RM = gl.getUniformLocation(prog_RM, "normalMatrix");
    u_inverseViewTransform_RM = gl.getUniformLocation(prog_RM, "inverseViewTransform");
    gl.enable(gl.DEPTH_TEST);
   
    gl.useProgram(prog_SB);
    mat4.perspective(projection_SB, Math.PI/4, 1, 1, 100);
    gl.uniformMatrix4fv(u_projection_SB, false, projection_SB);
    
    skyboxCube = createModelSB( cube(100) );
    
    gl.useProgram(prog_RM);
    mat4.perspective(projection_RM, Math.PI/4, 1, 1, 10);
    gl.uniformMatrix4fv(u_projection_RM, false, projection_RM);
    
    objects_RM = new Array(3);
    objects_RM[0] = createModelRM( uvSphere(0.6,64,32) );
    objects_RM[1] = createModelRM( uvCylinder() );
    objects_RM[2] = createModelRM( uvCone() );
    
    // first display image texture
      gl.useProgram(prog);
    gl.enable(gl.DEPTH_TEST);
      

    /* Get attribute and uniform locations */
    a_coords_loc =  gl.getAttribLocation(prog, "a_coords");
    a_normal_loc =  gl.getAttribLocation(prog, "a_normal");
    a_texCoords_loc =  gl.getAttribLocation(prog, "a_texCoords");
    gl.enableVertexAttribArray(a_coords_loc);
    gl.enableVertexAttribArray(a_normal_loc);
    gl.enableVertexAttribArray(a_texCoords_loc);
    
    u_modelview = gl.getUniformLocation(prog, "modelview");
    u_projection = gl.getUniformLocation(prog, "projection");
    u_normalMatrix =  gl.getUniformLocation(prog, "normalMatrix");
    u_textureNum = gl.getUniformLocation(prog, "textureNum");
    u_scale = gl.getUniformLocation(prog, "scale");
    
     u_picture = gl.getUniformLocation(prog, "picture");
     u_flag = gl.getUniformLocation(prog, "flag");
     
     gl.uniform1i(u_flag,1);
    
    gl.uniform1i(u_picture,0); // gl.TEXTURE0
    picture = gl.createTexture();
    gl.bindTexture(gl.TEXTURE_2D, picture);
    
    mat4.perspective(projection, Math.PI/10, 1, 1, 10);
    gl.uniformMatrix4fv(u_projection, false, projection);
    
    objects = new Array(3);
    objects[0] = createModel( uvSphere(0.6,64,32) );
    objects[1] = createModel( uvCylinder() );
    objects[2] = createModel( uvCone() );

}

function chooseDrawFunc() {
    if ( flag == 0 ) {
        draw_proc();
    } else if (flag == 1 ) {
        draw_image();
    } else {
        draw_envmap();
    }
}
        

function init() {
    try {
        canvas = document.getElementById("webglcanvas");
        gl = canvas.getContext("webgl") || 
                         canvas.getContext("experimental-webgl");
        if ( ! gl ) {
            throw "Browser does not support WebGL";
        }
    }
    catch (e) {
        document.getElementById("canvas-holder").innerHTML =
            "<p>Sorry, could not get a WebGL graphics context.</p>";
        return;
    }
    try {
        initGL();  // initialize the WebGL graphics context
    }
    catch (e) {
        document.getElementById("canvas-holder").innerHTML =
            "<p>Sorry, could not initialize the WebGL graphics context:" + e + "</p>";
        return;
    }
    
    // opening scene
    document.getElementById("object").value = "0";
    document.getElementById("scale").value = "10.0";
    flag = 1;
     document.getElementById("pics").value = "0";
     loadPicture();
    document.getElementById("pics").onchange = function() {
        console.log("image");
        flag = 1; 
        loadPicture();
        draw_image();
    }
    
    $("#texture").on("click", function () {
        flag = 0;
        gl.useProgram(prog);
        gl.uniform1i(u_flag, 0);
        draw_proc();
    });
    
    $("#pics").on("click", function () {
        flag = 1;
        console.log("clicked pics");
        gl.useProgram(prog);
        gl.uniform1i(u_flag, 1);
        loadPicture();
        draw_image();
    });
    
     $("#env").on("click", function () {
        flag = 2;
        loadTextureCube();
        draw_envmap();
    });
    document.getElementById("texture").onchange = function() {
     console.log("procedural");
        flag = 0; 
        draw_proc();
        }
    document.getElementById("scale").onchange = draw_proc;
    
    document.getElementById("object").onchange = function() {
       if ( flag == 0 ) {
            draw_proc();
        } else if ( flag == 1) {
            draw_image();
        } else {
            draw_envmap();
        }
    }
    
    document.getElementById("reset").onclick = function() {
        tballRotator.setView(5,[2,2,3]);
        rotX = rotY = 0;
        rotator.setAngles(0,0);
        if ( flag == 0 ) {
            draw_proc();
        } else if ( flag == 1) {
            draw_image();
        } else {
            draw_envmap();
        }
    }
    
    tballRotator = new TrackballRotator(canvas, chooseDrawFunc, 5, [2,2,3]);
    rotator = new SimpleRotator(canvas,chooseDrawFunc,2.7);
    if ( flag == 0 ) {
            draw_proc();
    } else if ( flag == 1) {
            draw_image();
    } else {
            draw_envmap();
    }
    
 }
 window.onload=init;
</script>
</head>


<body>
<div id="content">
    <h3>WebGL Assignment 5: Texture Mapping</h3>

    <div id="canvas-holder">
        <canvas id="webglcanvas" width="600" height="600"></canvas>
    </div>
    <div id="tools">
        <p><label><b>Objects:</b><br>
        <select id="object">
            <option value="0">Sphere</option>
            <option value="1">Cylinder</option>
            <option value="2">Cone</option>
        </select></label></p>
        <p><label><b>Image Texture:</b><br> 
        <select id="pics">
            <option value="0">Petrified Wood</option>
            <option value="1">Earth</option>
            <option value="2">Earth Lights</option>
            <option value="3">Moon</option>
        </select></label></p>
        
        <p><label><b>Computed Texture:</b><br> 
        <select id="texture">
            <option value="0">Checkerboard 2D</option>
            <option value="1">Checkerboard 3D</option>
            <option value="2">Triangle Function</option>
        </select></label></p>
        
        <p><label><b>Texture Scale:</b><br> <select id="scale">
            <option>20.0</option>
            <option>16.0</option>
            <option>12.0</option>
            <option>10.0</option>
            <option>8.0</option>
            <option>4.0</option>
            <option>2.0</option>
        </select></label></p>

        <p><label><b>Environment Map:</b><br> 
        <select id="env">
            <option value="0">Scene 1</option>
        </select></label></p>
            
        <p><button id="reset">Reset Scene</button></p>
        <p class="ins"> Please Use Mouse To Rotate</p>
        <p class="notes"> The texture images may take a few seconds to load or little more in case of Environment mapping,
        please be patient!</p>
    </div>

<div id="headline" style="display:none"></div>
</div>

</body>
</html>
